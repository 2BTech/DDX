# DDX Development State

## Finishing the DDX-RPC Implementation

### Registration
I still haven't finalized what information is sent during registration or how incoming register requests are handled.  The basic process is as follows.  Upon connection, registration should be sent (see code for RemDev::connectionReady()).  Until registration is complete, all incoming requests, notifications, and responses will be sent to the corresponding handleReg* functions.  RemDev::state can be used to manage what parts of registration are complete.  Both devices must send a `register` request and both must be responded to successfully in order for a connection to be marked "registered".  When registration is complete, set RemDev::registered to true and call DevMgr::markDeviceRegistered.  Failures in the registration process should not terminate
the connection - let the registration timeout poller handle that.

So here's the deal.  Outbound RemDev subclass constructors should probably pass a `RegInfo` struct or similar to the RemDev constructor.  This should be saved and should include any information to be sent in the `register` request which cannot be determined at the time the request is sent.  For example, passwords, roles and the `Target` string may need to be included.  Once the foreign request comes in, registration must be checked for compatability.  If any part of it fails, simply respond with failure.  

### Porting to Daemon
To begin with, the following files need to be copied to the Daemon directory:

- ddxrpc.h
- devmgr.h
- netdev.h
- remdev.h
- Corresponding .cpp files for the previous three (ddxrpc.h is just a header)

Then, the network.* files need to be ported over.  These already exist in the Daemon directory, although those versions are very outdated.  Read through the settings listed in Settings::registerSettings().  All of these which apply to the server, NetDev, or RemDev must be then be read from in the ported versions (the testgui just sets them in code).  Note that some settings may need to matched up with how they will be used in code and vice-versa.  Also note that while developing, it is useful to always launch the daemon with the "-reconfigure" option to force updating settings on every execution.

The Daemon class will have to instantiate DevMgr much like it currently does Settings.

### Request Dispatching
There's a part of DevMgr::dispatchRequest() which says "custom dispatching rules here".
In the Daemon, code here can dispatch requests/notifications to different subsystems based
on the beginning of the method string.  For example, you can simply write a function in the
Settings class with the prototype `void Settings::handleRequest(Request *req)` that is called whenever
the method starts with "settings.".  This can avoid expensive calls to invokeMethod(), which are required by handlers registered with addHandler.  However, note that this does lose the threading advantage to invokeMethod, so direct request handling should be reserved for operations which will complete fairly quickly and are thread-safe.

### Eventual things
Setting up proxy usage, possibly implementing UPnP.  We probably don't need to worry about either of these for now.

## Logging
Currently, no actual logging is done.  The only thing that happens is it echoes log messages to stdout/stderr.  Two main types of logging should happen.  First, the Logger class should maintain a list of all the connected devices which are listening to log messages; these should get a copy of each logline as a `log` notification.  Also, there should be file logs that save logs to disk.  It should keep track of the size of the logging directory and automatically compress or delete the oldest logs as necessary (should be managed by settings).  Current code pushes loglines into a queue, but they are never dequeued.  I would recommend connecting a slot to the Daemon::twoMinuteTimer() signal for processing the queue the rest of the way and also processing it in the Logger destructor and when a GUI connects.  This will prevent logs from being lost because they were generated before full logging framework has been initiated.

### Path-specific Logging
Listeners to a path should be able to listen to log messages generated by paths without listening to all log messages.

## Inlet API


## Directory Management
Daemon installations should have 

## Data Flow

### Potentially Adding Column Metadata

## Global changes

### Migrate to RapidJSON

## Process Support
If using a local GUI process, there should be a daemon setting which allows the daemon to keep an eye on the GUI process.  GUI processes by default should be watching local daemons.  If either shuts down, the other should try to resurrect the previous by executing the command.

## Random Documentation Stuff
There have been many instances where I wrote a function, documented it, and then completely rewrote the function without updating the documentation.  So take a lot of function documentation with a grain of salt - it might not be accurate.  If something sounds weird, either the documentation is old, the function needs to be updated to fit in with other parts of the system which have changed, or, equally likely, I wrote it horribly and it needs to be fixed.

Also, I have not really updated the `Settings` or `Config` formats here